<?php

use \owzim\FieldtypeDataStructure\FTDS;

class FieldtypeDataStructure extends FieldtypeTextarea {

    const DEFAULT_FONT_FAMILY = 'Consolas, Monaco, "Andale Mono", monospace';

    protected static $parseCache = array();

    public static function getModuleInfo() {
        return array(
            'title' => 'Fieldtype DataStructure',
            'summary' => 'Field that stores any structural string-based data and converts it to object or array, when requested.',
            'version' => '0.4.4',
            'author' => 'owzim',
            'icon' => 'code',
            'tests' => array(
                'title' => 'Fieldtype DataStructure',
                'classPath' => './tests/FieldtypeDataStructureTests.php'
            )
        );
    }


    public function init() {
        parent::init();
        require_once(__DIR__ . '/owzim/FieldtypeDataStructure/Autoloader.php');
        spl_autoload_register('owzim\FieldtypeDataStructure\Autoloader::autoload');
        $this->addHookAfter('Fields::save', $this,  'saveDefaultValues');
    }

    protected function saveDefaultValues(HookEvent $event) {
        $field = $event->arguments[0];
        $fieldtype = (string) $field->type;

        // only continue if the field is type of this class
        if ($fieldtype !== get_class($this)) return;

        // only run if the defaults have not been saved before
        if (!is_null($field->isInit)) return;

        // save the defaults and the initialized state
        $field->inputType = $this->getValue($field, 'inputType');
        $field->outputAs = $this->getValue($field, 'outputAs');
        $field->fontFamily = $this->getValue($field, 'fontFamily', $this);
        $field->delimiter = $this->getValue($field, 'delimiter');
        $field->isInit = 1;
        $field->save();

        // ChromePhp::log('$field',$fieldtype ,  get_class($this));
    }


    public function ___formatValue(Page $page, Field $field, $value) {
        return $this->getCachedValue($page, $field, $value);
    }

    public function getCachedValue(Page $page, Field $field, $value) {

        $cacheKey = "{$page->id}_{$field->id}";
        
        // if it's not cached yet, parse, save to cache and return
        if (!isset(self::$parseCache[$cacheKey])) {
            return self::$parseCache[$cacheKey] = $this->parseValue($page, $field, $value);
        } else { // return the cached value
            return self::$parseCache[$cacheKey];
        }
    }

    /**
     * remove the cached value of a field of a page
     *
     * @param  Page   $page
     * @param  Field  $field
     */
    public function uncache(Page $page, Field $field) {
        $cacheKey = "{$page->id}_{$field->id}";
        if (isset(self::$parseCache[$cacheKey])) {
            unset(self::$parseCache[$cacheKey]);
        }
    }

    /**
     * hook in here to add additional parsers
     */
    public function ___parseValue(Page $page, Field $field, $value) {
        return FTDS::parseInput(
            $value,
            array(
                'inputType' => $this->getValue($field, 'inputType'),
                'outputAs' => $this->getValue($field, 'outputAs'),
                'delimiter' => $this->getValue($field, 'delimiter'),
                'toStringString' => $field->get('label|name'),
            )
        );
    }


    public function getInputfield(Page $page, Field $field) {

        $fontFamily = trim($this->getValue($field, 'fontFamily', $this));
        $process = $this->wire('page')->process;

        // convert to InputfieldText, if only one row is set but only if not on
        // edit field page, because it would cause the edit field page to show
        // only options for InputfieldText, not sure why
        if ($process !== 'ProcessField' && $field->rows == 1) {
            $inputfield = $this->modules->get('InputfieldText');
        } else {
            $inputfield = parent::getInputfield($page, $field);
        }

        if (!empty($fontFamily)) {
            $inputfield->attr('style', "font-family: {$fontFamily}");
        }

        $inputfield->class = $this->className();
        return $inputfield;
    }


    public function ___getConfigInputfields(Field $field) {

        // $value = $this->getValue('inputType');
        // $value = $this->getValue('fontFamily', $this);

        $inputfields = new InputfieldWrapper();

        $inputfields->append($this->getConfigInputfieldInputType($field));
        $inputfields->append($this->getConfigInputfieldDelimiter($field));
        $inputfields->append($this->getConfigInputfieldOutputAs($field));
        $inputfields->append($this->getConfigInputfieldFontFamily($field));
        $inputfields->append($this->getConfigInputfieldInputfieldClass($field));

        return $inputfields;
    }

    public function ___getConfigInputfieldInputfieldClass(Field $field) {
        $inputfields = parent::___getConfigInputfields($field);
        foreach ($inputfields as $inputfield) {
            if ($inputfield->name == 'inputfieldClass') {
                $inputfield->attr('icon', 'list-alt');
                return $inputfield;
            }
        }
    }

    /**
     * get the possible input types
     * hook in here to add more types
     *
     * @return array
     */
    public function ___getInputTypes() {
        return array(
            FTDS::INPUT_TYPE_YAML => $this->_('YAML (Object/Array)'),
            FTDS::INPUT_TYPE_MATRIX => $this->_('Matrix, delimiter and line-break separated (Array)'),
            FTDS::INPUT_TYPE_MATRIX_OBJECT => $this->_('Matrix, first row as keys (Object/Array)'),
            FTDS::INPUT_TYPE_DELIMITER_SEPARATED => $this->_('Delimiter separated (Array)'),
            FTDS::INPUT_TYPE_LINE_SEPARATED => $this->_('Line-break separated (Array)'),
            FTDS::INPUT_TYPE_JSON => $this->_('JSON (Object/Array)'),
        );
    }

    public function ___getConfigInputfieldInputType(Field $field) {

        $inputTypes = $this->getInputTypes();

        $f = $this->modules->get('InputfieldSelect');
        $f->attr('name', 'inputType');
        $f->attr('value', $this->getValue($field, 'inputType'));
        foreach ($inputTypes as $key => $value) {
            $f->addOption($key, $value);
        }
        $f->label = $this->_('Input type');
        $f->icon = 'sign-in';
        // $f->columnWidth = 70;
        return $f;
    }

    public function ___getConfigInputfieldOutputAs(Field $field) {

        $f = $this->modules->get('InputfieldSelect');
        $f->attr('name', 'outputAs');
        $f->attr('value', $this->getValue($field, 'outputAs'));
        $f->addOption(FTDS::OUTPUT_AS_WIRE_DATA, $this->_('WireData/-Array'));
        $f->addOption(FTDS::OUTPUT_AS_OBJECT, $this->_('Object'));
        $f->addOption(FTDS::OUTPUT_AS_ASSOC, $this->_('Associative Array'));
        $f->label = $this->_('Output object as');
        $f->icon = 'sign-out';
        $f->description = $this->_(preg_replace("/(\\n|\s)+/", ' ', '
            If **WireData/-Array** is selected, the parsed array/object has full
            support for things like **$page->people->implode(\',\', \'name\')**
            (arrays) or **$person->get(\'title|name\')** (objects). **WireArray**
            will fall back to regular array, it its children are not of type
            **object/stdClass** or **WireData**.
        '));

        $f->showIf = $this->showIfList('inputType!=', array(
            FTDS::INPUT_TYPE_MATRIX,
            FTDS::INPUT_TYPE_DELIMITER_SEPARATED,
            FTDS::INPUT_TYPE_LINE_SEPARATED,
        ));

        return $f;
    }


    public function ___getConfigInputfieldDelimiter(Field $field) {

        $f = $this->modules->get('InputfieldText');
        $f->attr('name', 'delimiter');
        $f->attr('value', $this->getValue($field, 'delimiter'));
        $f->size = 5;
        $f->label = $this->_('Delimiter');
        $f->icon = 'arrows-h';
        // $f->columnWidth = 30;
        $f->showIf = $this->showIfList('inputType!=', array(
            FTDS::INPUT_TYPE_YAML,
            FTDS::INPUT_TYPE_LINE_SEPARATED,
            FTDS::INPUT_TYPE_JSON,
        ));

        return $f;
    }

    // public function ___getConfigInputfieldsCSV(Field $field) {

    //     $f = $this->modules->get('InputfieldText');
    //     $f->attr('name', 'csvDelimiter');
    //     $f->label = $this->_('CSV delimiter');
    //     $f->attr('value', !isset($field->csvDelimiter) ? FTDS::DEFAULT_CSV_DELIMITER : $field->csvDelimiter);
    //     $f->attr('optionColumns', 1);
    //     $f->icon = 'sign-out';
    //     $f->description = $this->_(implode(' ', array(
    //         'If **WireData/-Array** is selected, the parsed array/object has full',
    //         'support for things like **$page->people->implode(\',\', \'name\')** (arrays)',
    //         'or **$person->get(\'title|name\')** (objects).',
    //         '**WireArray** will fall back to regular array, it its children',
    //         'are not of type **object/stdClass** or **WireData**.',
    //     )));

    //     $f->showIf = $this->showIfList('inputType!=', array(
    //         FTDS::INPUT_TYPE_MATRIX,
    //         FTDS::INPUT_TYPE_DELIMITER_SEPARATED,
    //         FTDS::INPUT_TYPE_LINE_SEPARATED,
    //     ));

    //     return $f;
    // }

    public function ___getConfigInputfieldFontFamily(Field $field) {

        $fontFamily = trim($this->getValue($field, 'fontFamily', $this));

        $f = $this->modules->get('InputfieldText');
        $f->attr('name', 'fontFamily');
        $f->attr('value', $fontFamily);
        if (!empty($fontFamily)) {
            $f->attr('style', "font-family: {$fontFamily}");
        }
        $f->label = $this->_('Font Family');
        $f->notes = $this->_('Preview after save');
        $f->icon = 'font';

        return $f;
    }

    public function showIfList($condition, $items) {
        return $condition . implode(', ' . $condition, $items);
    }


    public function getValue(Field $field, $name, $class = '\owzim\FieldtypeDataStructure\FTDS') {

        preg_match_all('/((?:^|[A-Z])[a-z]+)/',$name,$matches);
        $items = $matches[0];

        foreach ($items as $k => $v) $items[$k] = strtoupper($v);
        $ucName = implode('_', $items);
        $defaultName = "{$class}::DEFAULT_{$ucName}";

        if (!defined($defaultName)) {
            throw new Exception("Constant '$defaultName' not defined");
        }

        $defaultValue = constant($defaultName);

        // ChromePhp::log($defaultName, constant($defaultName));

        if (isset($field->$name)) {
            $value = $field->$name;
        } else {
            $value = $defaultValue;
        }

        return is_int($defaultValue) ? (int) $value : $value;
    }
}
