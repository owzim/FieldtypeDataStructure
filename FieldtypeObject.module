<?php

use \owzim\FieldtypeObject\FTO;

class FieldtypeObject extends FieldtypeTextarea {

    const DEFAULT_FONT_FAMILY = 'Consolas, Monaco, "Andale Mono", monospace';

    protected static $parseCache = array();

    public static function getModuleInfo() {
        return array(
            'title' => 'Fieldtype Object',
            'summary' => 'Field that stores any structural string-based data and formats it as an object, when requested.',
            'version' => '0.3.0',
            'author' => 'owzim',
            'icon' => 'code',
            'tests' => array(
                'title' => 'Fieldtype Object',
                'classPath' => './tests/FieldtypeObjectTests.php'
            )
        );
    }


    public function init() {
        parent::init();
        require_once(__DIR__ . '/owzim/FieldtypeObject/Autoloader.php');
        spl_autoload_register('owzim\FieldtypeObject\Autoloader::autoload');
    }


    public function ___formatValue(Page $page, Field $field, $value) {
        return $this->getCachedValue($page, $field, $value);
    }

    public function getCachedValue(Page $page, Field $field, $value) {

        $cacheKey = "{$page->id}_{$field->id}";

        if (!isset(self::$parseCache[$cacheKey])) {
            return self::$parseCache[$cacheKey] = $this->parseValue($page, $field, $value);
        } else {
            return self::$parseCache[$cacheKey];
        }
    }

    /**
     * hook in here to add additional parsers
     */
    public function ___parseValue(Page $page, Field $field, $value) {
        return FTO::parseInput(
            $value,
            !isset($field->inputType) ? FTO::DEFAULT_INPUT_TYPE : (int) $field->inputType,
            !isset($field->outputAs) ? FTO::DEFAULT_OUTPUT_AS : (int) $field->outputAs,
            $field->get('label|name')
        );
    }


    public function getInputfield(Page $page, Field $field) {

        $fontFamily = trim(!isset($field->fontFamily) ? self::DEFAULT_FONT_FAMILY : $field->fontFamily);
        $process = $this->wire('page')->process;

        // convert to InputfieldText, if only one row it set but only if not on
        // edit field page, because it would cause the edit field page to show
        // only options for InputfieldText, not sure why
        if ($process !== 'ProcessField' && $field->rows == 1) {
            $inputfield = $this->modules->get('InputfieldText');
        } else {
            $inputfield = parent::getInputfield($page, $field);
        }

        if (!empty($fontFamily)) {
            $inputfield->attr('style', "font-family: {$fontFamily}");
        }

        $inputfield->class = $this->className();
        return $inputfield;
    }


    public function ___getConfigInputfields(Field $field) {

        $inputfields = new InputfieldWrapper();

        $inputfields->append($this->getConfigInputfieldInputType($field));
        $inputfields->append($this->getConfigInputfieldOutputAs($field));
        $inputfields->append($this->getConfigInputfieldFontFamily($field));
        $inputfields->append($this->getConfigInputfieldInputfieldClass($field));

        return $inputfields;
    }

    public function ___getConfigInputfieldInputfieldClass(Field $field) {
        $inputfields = parent::___getConfigInputfields($field);
        foreach ($inputfields as $inputfield) {
            if ($inputfield->name == 'inputfieldClass') {
                $inputfield->attr('icon', 'list-alt');
                return $inputfield;
            }
        }
    }

    /**
     * get the possible input types
     * hook in here to add more types
     *
     * @return array
     */
    public function ___getInputTypes() {
        return array(
            FTO::INPUT_TYPE_YAML => $this->_('YAML (Object)'),
            FTO::INPUT_TYPE_MATRIX => $this->_('Matrix, comma and line-break separated (Array)'),
            FTO::INPUT_TYPE_COMMA_SEPARATED => $this->_('Comma separated (Array)'),
            FTO::INPUT_TYPE_LINE_SEPARATED => $this->_('Line-break separated (Array)'),
            FTO::INPUT_TYPE_JSON => $this->_('JSON (Object)'),
        );
    }

    public function ___getConfigInputfieldInputType(Field $field) {

        $f = $this->modules->get('InputfieldSelect');
        $f->attr('name', 'inputType');
        $f->label = $this->_('Input type');

        $inputTypes = $this->getInputTypes();

        foreach ($inputTypes as $key => $value) {
            $f->addOption($key, $value);
        }
        $f->attr('optionColumns', 1);
        $value = !isset($field->inputType) ? FTO::DEFAULT_INPUT_TYPE : (int) $field->inputType;
        $f->attr('value', $value);
        $f->attr('icon', 'sign-in');
        return $f;
    }

    public function ___getConfigInputfieldOutputAs(Field $field) {

        $f = $this->modules->get('InputfieldSelect');
        $f->attr('name', 'outputAs');
        $f->label = $this->_('Output object as');
        $f->addOption(FTO::OUTPUT_AS_WIRE_DATA, $this->_('WireData/-Array'));
        $f->addOption(FTO::OUTPUT_AS_OBJECT, $this->_('Object'));
        $f->addOption(FTO::OUTPUT_AS_ASSOC, $this->_('Associative Array'));
        $f->attr('value', !isset($field->outputAs) ? FTO::DEFAULT_OUTPUT_AS : (int) $field->outputAs);
        $f->attr('optionColumns', 1);
        $f->attr('icon', 'sign-out');
        $f->description = $this->_(implode(' ', array(
            'If **WireData/-Array** is selected, the parsed array/object has full',
            'support for things like **$page->people->implode(\',\', \'name\')** (arrays)',
            'or **$person->get(\'title|name\')** (objects).',
            '**WireArray** will fall back to regular array, it its children',
            'are not of type **object/stdClass** or **WireData**.',
        )));

        $f->showIf = $this->showIfList('inputType!=', array(
            FTO::INPUT_TYPE_MATRIX,
            FTO::INPUT_TYPE_COMMA_SEPARATED,
            FTO::INPUT_TYPE_LINE_SEPARATED,
        ));

        return $f;
    }

    public function ___getConfigInputfieldFontFamily(Field $field) {

        $fontFamily =
            trim(!isset($field->fontFamily)
            ? self::DEFAULT_FONT_FAMILY
            : $field->fontFamily);

        $f = $this->modules->get('InputfieldText');
        $f->attr('name', 'fontFamily');
        $f->label = $this->_('Font Family');
        $f->notes = $this->_('Preview after save');
        $f->attr('value', $fontFamily);
        $f->attr('icon', 'font');
        if (!empty($fontFamily)) {
            $f->attr('style', "font-family: {$fontFamily}");
        }
        return $f;
    }

    public function showIfList($condition, $items) {
        return $condition . implode(', ' . $condition, $items);
    }
}
